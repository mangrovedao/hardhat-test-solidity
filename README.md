# hardhat-test-solidity

üí° Inspired by [dapptools](https://github.com/dapphub/dapptools)'s [ds-test](https://github.com/dapphub/ds-test).

‚ö†Ô∏è Requires [hardhat-deploy](https://github.com/wighawag/hardhat-deploy) as a peer dependency.

## tl;dr
Tests suites are solidity contracts, tests are solidity functions.
> hardhat.config.js
```javascript
require('hardhat-test-solidity');
```

> MyContract_Test.sol:
```solidity
// Adds Test library to the context
import Test from "hardhat-test-solidity/test.sol";

// `_Test` suffix means it is a test contract
contract MyContract_Test {

  // `_test` suffix means it is a test contract
  function addition_test() public {
    prepare();
    // Logging will be interpreted by hardhat-test-solidity
    Test.eq(4,2+2,"oh no");
  }

  // Will not be interpreted as a test function
  function prepare() {}
}
```

> terminal
```
$ npx hardhat test-solidity MyContract
```

## How to structure test contract
* All contracts with suffix `_Test` are test contracts.
* All public functions with suffix `_test` are test functions.
* All public functions with suffix `_beforeAll` setup the state before other tests.
* If you have the functions `fn_test` and `fn_before`, `fn_before` will run, then `fn_test`, without state revert.

### Tips
* State is reverted between tests
* Functions are sorted alphabetically before they are added to test suite
* You probably want a `MyContract_Test` for every `MyContract`.

## How to test for stuff
* `Test.check(bool success,string memory message)` suceeds if `success` is true.
* `Test.eq(actual,expected,message)` for testing `bytes32`, `bool`, `string`, `uint`, `address` equality.
* `Test.eq0(actual,expected,message)` for testing `bytes` equality.
* `Test.less(uint a, uint b,message)` succeeds if `a < b`.
* `Test.more(uint a, uint b,message)` succeeds if `a > b`.
* `Test.fail(message)` to always fail.
* `Test.succeed()` to always succeed.

## How to test for event emission
Suppose you want to make sure that contract `Market` emits the `Trade` event.
```
import "hardhat-test-solidity";
contract My_Test {
  Market amm;

  function _beforeAll() {
    amm = new Market()
  }

  function first_test() {
    Market.trade();

    Test.expect_from(amm);
    emit Market.Trade();
  }
}
```

So: you _emit_ an event (with any arguments you like), and the plugin will check that `amm` has already emitted the exact same event.


### Tips
* For a given address, the order of events matters. Between addresses it does not.
* Events are checked _after their emission_. So do all your test, and at the end test for events. 


## How to use the command line
`npx hardhat test-solidity [contract names without _Test] [--prefix function_prefix]`

Add `--details` for more detailed logging, including logs generated by the `logFormatters` plugin option (see below).

For more CLI options look at
> `npx hardhat test-solidity --help`

### Tip
If you want to only run the test `breath_is_fire_test` in the testing contract `Dragon_Test`, and you have 10 testing contracts, run 

```test-solidity Dragon --prefix breath_is_fire``` 

rather than just 

```test-solidity --prefix breath_is_fire``` 

so you don't waste time deploying all the other test suite contracts.

## How to log
To get nicely-formatted logs, use the `Display` library. There are
* `Display.log(uint|string)`
* `Display.log(uint|string,uint|string)`
* `Display.log(uint|string,uint|string,uint|string)`
* `Display.logBalances(address[1] memory tokens, address a0)`
* `Display.logBalances(address[1] memory tokens, address a0, address a1)`
* `Display.logBalances(address[1] memory tokens, address a0, address a1, address a2)`
* `Display.logBalances(address[2] memory tokens, address a0)`
* `Display.logBalances(address[2] memory tokens, address a0, address a1)`
* `Display.logBalances(address[2] memory tokens, address a0, address a1, address a2)`

## How to register addresses
To get pretty-printing of addresses, in your test setup do

```solidity
import {Display as D} from "hardhat-test-solidity/test.sol";
...
D.register(address addr, string memory name)
```

and your and events will display `name` instead of `addr`. In particular the `--show-events` switch which shows all events emitted by non-test contracts, will replace registered addresses with names as well. 


## How to configure the plugin
> `hardhat.config.js`
```javascript
{
  ...,
  testSolidity: { // default values as follows:
    timeout: 300_000 /* test suite timeout in ms */,
    logFormatters: (hre,formatArg) => { return {}; } /* format logs */
  }
}
```

### `logFormatters`
`logFormatters(hre,formatArg):object` is a function that takes the `hre` hardhat runtime environment and a `formatArg(arg,type?):string` utility function. `arg` is dynamically tested and `type` is an optional type hint (it can be `uint`, `address`, or an array of type hints) to help formatting.

`logFormatters` should return an object where keys are event names and values are formatting functions that should directly log to console and have type:

```typescript
(log:ethers.LogDescription,rawLog:{topics,data},originator:string):void
```

See `src/logFormatters.js` for examples.

## Debugging

This plugin uses the [debug](https://www.npmjs.com/package/debug) package. To debug this plugin only do:

> `DEBUG='hardhat:test-solidity' npx hardhat test-solidity [args]`


# Hardhat TypeScript plugin boilerplate

This is a sample Hardhat plugin written in TypeScript. Creating a Hardhat plugin
can be as easy as extracting a part of your config into a different file and
publishing it to npm.

This sample project contains an example on how to do that, but also comes with
many more features:

- A mocha test suite ready to use
- TravisCI already setup
- A package.json with scripts and publishing info
- Examples on how to do different things

## Installation

To start working on your project, just run

```bash
npm install
```

## Plugin development

Make sure to read our [Plugin Development Guide](https://hardhat.org/advanced/building-plugins.html) to learn how to build a plugin.

## Testing

Running `npm run test` will run every test located in the `test/` folder. They
use [mocha](https://mochajs.org) and [chai](https://www.chaijs.com/),
but you can customize them.

We recommend creating unit tests for your own modules, and integration tests for
the interaction of the plugin with Hardhat and its dependencies.

## Linting and autoformat

All of Hardhat projects use [prettier](https://prettier.io/) and
[tslint](https://palantir.github.io/tslint/).

You can check if your code style is correct by running `npm run lint`, and fix
it with `npm run lint:fix`.

## Building the project

Just run `npm run build` Ô∏èüë∑

## README file

This README describes this boilerplate project, but won't be very useful to your
plugin users.

Take a look at `README-TEMPLATE.md` for an example of what a Hardhat plugin's
README should look like.

## Migrating from Buidler?

Take a look at [the migration guide](MIGRATION.md)!
